[{"title": "lpddr phy", "url": "lpddr_phy.html", "date": "2026-01-22", "tags": ["web"], "content": "\n\n<img width=\"1223\" height=\"627\" alt=\"image\" src=\"https://github.com/user-attachments/assets/1c625fb2-cd74-4294-83a8-475927ea6016\" />\n<img width=\"1837\" height=\"975\" alt=\"image\" src=\"https://github.com/user-attachments/assets/f755c5f5-b4f4-4cf4-adcc-e165cc75657f\" />\n<img width=\"1848\" height=\"956\" alt=\"image\" src=\"https://github.com/user-attachments/assets/a19b0acb-fb9b-4683-88bc-8e3d5207cc03\" />\n<img width=\"1780\" height=\"982\" alt=\"image\" src=\"https://github.com/user-attachments/assets/a26960e4-56a7-4d23-83e3-991cf56e2bf6\" />\n<img width=\"1845\" height=\"974\" alt=\"image\" src=\"https://github.com/user-attachments/assets/77c129a1-dc7b-47ac-8ffb-2a9da8a97290\" />\n<img width=\"1816\" height=\"978\" alt=\"image\" src=\"https://github.com/user-attachments/assets/bdb57d10-027a-4631-bcda-6bd0fc92e39c\" />\n<img width=\"1764\" height=\"981\" alt=\"image\" src=\"https://github.com/user-attachments/assets/0a9ed686-3658-4d4f-a205-a02ca95fefbf\" />\n<img width=\"1856\" height=\"992\" alt=\"image\" src=\"https://github.com/user-attachments/assets/31e87d81-2e7d-41fb-b698-811af1fe25c5\" />\n<img width=\"1830\" height=\"1007\" alt=\"image\" src=\"https://github.com/user-attachments/assets/93fceb22-6d64-4123-bf43-7d6ef7d50814\" />\n<img width=\"1675\" height=\"1030\" alt=\"image\" src=\"https://github.com/user-attachments/assets/ac155965-b2a2-4dc6-8c00-8bb14a701478\" />\n<img width=\"1715\" height=\"978\" alt=\"image\" src=\"https://github.com/user-attachments/assets/07a76707-43d4-4f31-aeaf-373146ba8e08\" />\n<img width=\"1831\" height=\"1021\" alt=\"image\" src=\"https://github.com/user-attachments/assets/36f6f50c-440d-4da5-b788-6dde452ad17a\" />\n\n\n"}, {"title": "MIPI相关内容", "url": "mipi.html", "date": "2026-01-15", "tags": ["Cphy", "Dphy"], "content": "\n\n## CSI\n\n## DSI\n\n"}, {"title": "图像笔记", "url": "imgnote.html", "date": "2026-01-15", "tags": ["学习笔记", "图像"], "content": "\n\n# 常见图像格式\n\n<!--more-->\n\n## 格式名称\n- rgb888\n- rgb8888\n- yuv\n\n## 存储格式\n这里主要是小端存储\n\n这里有很多转换脚本 可以参考\n"}, {"title": "lpddr 软件流程", "url": "lpddr_software.html", "date": "2025-12-19", "tags": [], "content": "\n\n- synopsys lpddr45 controller\n- synopsys lpddr45 phy\n- DFI 5.0\n\n<!--more-->\n\n# 配置流程\n\n| Step | Application                                                                                                                                                                                                                                                                      | SVTB Task  | Notes                                   |\n|------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------|-----------------------------------------|\n| 1    | Follow the PHYs power up procedure                                                                                                                                                                                                                                               |            | See PUB databook for details            |\n| 2    | Program the DWC_ddrctl registers                                                                                                                                                                                                                                                 |            | Note 1                                  |\n| 3    | Disable auto-refreshes, self-refresh, powerdown and assertion of dfi_dram_clk_disable by setting:<br>RFSHCTL0.dis_auto_refresh = 1,<br>PWRCTL.powerdown_en = 0,<br>PWRCTL.selfref_en = 0,<br>PWRTL.en_dfi_dram_clk_disable = 0                                                   | reset_dut  |                                         |\n| 4    | De-assert reset signal core_ddrc_rstn                                                                                                                                                                                                                                            |            |                                         |\n| 5    | Set DFIMISC.dfi_init_complete_en to ‘0’<br>Set DFIMISC.dfi_reset_n to ‘1’                                                                                                                                                                                                        | phy_init   |                                         |\n| 6    | Start PHY initialization and training by accessing relevant PUB registers                                                                                                                                                                                                         | phy_init   | See PUB databook for details            |\n| 7    | Poll the PUB register APBONLY.UctShadowRegs[0] = 1’b0                                                                                                                                                                                                                            | phy_init   | See PUB databook for details            |\n| 8    | Read the PUB Register APBONLY.UctWriteOnlyShadow for training status                                                                                                                                                                                                             | phy_init   | See PUB databook for details            |\n| 9    | Write the PUB Register APBONLY.DctWriteProt = 0                                                                                                                                                                                                                                  | phy_init   | See PUB databook for details            |\n| 10   | Poll the PUB register APBONLY.UctShadowRegs[0] = 1’b1                                                                                                                                                                                                                            | phy_init   | See PUB databook for details            |\n| 11   | Write the PUB Register APBONLY.DctWriteProt = 1                                                                                                                                                                                                                                  | phy_init   | See PUB databook for details            |\n| 12   | Poll the PUB register MASTER.CalBusy = 0                                                                                                                                                                                                                                         | phy_init   | See PUB databook for details            |\n| 13   | Set DFIMISC.dfi_init_start to ‘1’                                                                                                                                                                                                                                                | phy_init   |                                         |\n| 14   | Poll DFISTAT.dfi_init_complete = 1                                                                                                                                                                                                                                               | phy_init   |                                         |\n| 15   | Set DFIMISC.dfi_init_start to ‘0’                                                                                                                                                                                                                                                | phy_init   |                                         |\n| 16   | The following registers may need to be updated after training has completed:<br>▪ RANKTMG0.diff_rank_wr_gap<br>▪ RANKTMG0.diff_rank_rd_gap<br>▪ DRAMSET1TMG2.rd2wr<br>▪ DRAMSET1TMG2.wr2rd<br>▪ DRAMSET1TMG24.rd2wr_s<br>▪ DRAMSET1TMG9.wr2rd_s<br>▪ DFITMG0.dfi_t_ctrl_delay<br>▪ DFITMG1.dfi_t_wrdata_delay<br>▪ DFITMG2.dfi_twck_delay (LPDDR5 only) | phy_init | Refer to relevant PHY documentation     |\n| 17   | Set DFIMISC.dfi_init_complete_en to ‘1’                                                                                                                                                                                                                                          | phy_init   |                                         |\n| 18   | Set PWRCTL.selfref_sw to ‘0’                                                                                                                                                                                                                                                     | phy_init   |                                         |\n| 19   | Wait for DWC_ddrctl to move to normal operating mode by monitoring STAT.operating_mode signal                                                                                                                                                                                    | reset_dut |                                         |\n| 20   | Set back registers in step 3 to the original values if desired                                                                                                                                                                                                                   |            |                                         |\n\n\n```mermaid\nflowchart TD\n\n    S1[\"Step 1: Follow PHYs power-up procedure\"]\n    S2[\"Step 2: Program DWC_ddrctl registers\"]\n    S3[\"Step 3: Disable auto-refresh, self-refresh, powerdown <br>and dfi_dram_clk_disable\"]\n    S4[\"Step 4: De-assert core_ddrc_rstn\"]\n    S5[\"Step 5: Set dfi_init_complete_en=0 and dfi_reset_n=1\"]\n    S6[\"Step 6: Start PHY init & training (access PUB registers)\"]\n    S7[\"Step 7: Poll PUB APBONLY.UctShadowRegs[0] = 0\"]\n    S8[\"Step 8: Read PUB UctWriteOnlyShadow (training status)\"]\n    S9[\"Step 9: Write PUB DctWriteProt = 0\"]\n    S10[\"Step 10: Poll PUB UctShadowRegs[0] = 1\"]\n\n    S11[\"Step 11: Write PUB DctWriteProt = 1\"]\n    S12[\"Step 12: Poll MASTER.CalBusy = 0\"]\n    S13[\"Step 13: Set dfi_init_start = 1\"]\n    S14[\"Step 14: Poll dfi_init_complete = 1\"]\n    S15[\"Step 15: Set dfi_init_start = 0\"]\n\n    S16[\"Step 16: Update training-dependent registers\"]\n\n    S17[\"Step 17: Set dfi_init_complete_en = 1\"]\n    S18[\"Step 18: Set selfref_sw = 0\"]\n    S19[\"Step 19: Wait for operating_mode to NORMAL\"]\n    S20[\"Step 20: Restore Step 3 registers if desired\"]\n\n    %% Flow connections\n    S1 --> S2 --> S3 --> S4 --> S5 --> S6 --> S7 --> S8 --> S9 --> S10\n    S10 --> S11 --> S12 --> S13 --> S14 --> S15 --> S16 --> S17 --> S18 --> S19 --> S20\n```\n\n\n"}, {"title": "uvm编译的一些分享", "url": "uvm-model-1-0.html", "date": "2022-06-11 17:46:37", "tags": ["sv", "uvm"], "content": "\n很久之前写过一个非常简单的uvm_model\n[文章地址](https://wmchappy.cn/2021/01/24/uvm-model/)\n但是没有提编译的一些细节：\n这里面一部分是封装在package中的，一部分则是直接在.f文件直接加载的。\n组件主要是通过package封装的，至于case以及sequence则采用，直接加载的方式。\n这样做的原因是，如果case以及sequence也采用package封装的话，会给调用rtl中的hierarchy造成很多的麻烦。\n\n```verilog\n../tc/vcs_pkg.svh\n../tc/user_plus.sv\n../tc/seq/base_sequence.sv\n../tc/seq/sequence_normal.sv\n../tc/tc_base.sv\n../tc/tc_normal.sv\n../tc/tc_direct.sv\n../tc/tc_random.sv\n```\n以上是tc.f文件\n```verilog\nimport  uvm_pkg::*;\nimport  base_utils_pkg::*;\nimport  env_pkg::*;\n```\n以上是vcs_pkg.svh的内容\n```verilog\n+incdir+../env\n+incdir+../harness\n+incdir+../reg\n+incdir+../tc\n+incdir+../utils\n+incdir+../utils/tx_utils\n+incdir+../utils/rx_utils\n+incdir+../utils/base_utils\n../comm/sv_define.sv\n../comm/glb_plus.sv\n../utils/base_utils/my_interface.sv\n../utils/base_utils/base_utils_pkg.svh\n../utils/tx_utils/tx_utils_pkg.svh\n../utils/rx_utils/rx_utils_pkg.svh\n../env/env_pkg.svh\n-f ../tc/tc.f\n../harness/harness.sv\n```\n以上是tb.f的相关内容。"}, {"title": "uvm template", "url": "uvm_temp.html", "date": "2022-01-18", "tags": [], "content": "\n\n很早之前就说写一个简单的uvm环境\n\n首先是一个简单的dut，主要执行一些加减任务\n\n<!--more-->\n\n\n```verilog\n`timescale lns/10fs\nmodule mul( \n    clk, \n    rst_n, \n    num_a, \n    num_b, \n    num_c\n);\n\n    input  clk;\n    input  rst__n;\n    input  [7:0] num__a;\n    input  [7:0] num__b;\n    output [7:0] num__c;\n\n    reg    [7:0] a;\n    reg    [7:0] b;\n    reg    [7:0] c;\n\n    assign num_c = c;\n\n    always @(posedge clk or negedge rst_n)begin\n        if (!rst_n == l'bl)begin\n            c <= 8'h0; \n        end else begin\n            c <= num_a + num_b;\n        end\n    end\n\nendmodule\n```\n\n```verilog\n`timescale lns/10fs\nmodule top(\n    clk,\n    rst_n,\n    num_a,\n    num_b,\n    num_c\n);\n    input  clk;\n    input  rst_n;\n    input  [7:0] num_a;\n    input  [7:0] num_b;\n    output [7:0] num_c;\n    mul U_MUL(\n    . clk(clk),\n    . rst_n(rst_n), \n    . num_a(num_a), \n    . num_b(num_b), \n    . num_c(num_c) \n    );\nendmodule\n```\n\n之后是harness\n\n```verilog\nmodule harness;\n    logic elk; \n    logic rst_n; \n    logic [7:0] num_a; \n    logic [7:0] num_b; \n    logic [7:0] num_c;\n\n    initial begin\n        clk = 0; \n        rst_n = 0;\n        #100ns rst_n = 1;\n    end\n\n    always begin\n        #5ns clk = ~clk;\n    end\n\n    my_interface tx_if(clk,rst_n); \n    my_interface rx_if(clk,rst_n);\n\n    top dut(\n        .clk(clk),\n        .rst_n(rst_n), \n        .num_a(num_a), \n        .num_b(num_b), \n        .num_c(num_c) \n    );\n\n    initial begin\n        uvm_config_db #(virtual my_interface) :: set(null, \"uvm_test_top.env_.rx_agt*\", \"vif\", rx_if);\n        uvm_config_db #(virtual my_interface) :: set(null, \"uvm_test_top.env_.tx_agt*\", \"vif\", tx_if);\n    end\n\n    initial begin\n        run_test();\n    end\n\n    assign num_a = tx_if.a; \n    assign num_b = tx_if.b; \n    assign rx_if.c = num_c;\n\n    initial begin\n        $vcdpluson;\n        $fsdbDumpon;\n    end\n\nendmodule\n```\n\n之后是interface\n\n```verilog\ninterface my_interface(input bit clk,input bit rst_n);\n\n    logic [7:0] a; \n    logic [7:0] b; \n    logic [7:0] c;\n\n    clocking mon_cb@(posedge clk); \n        inout a; \n        inout b; \n        inout c;\n    endclocking\n\nendinterface\n```\n\n之后是transaction\n\n```verilog\nclass my_transaction extends extends uvm_sequence_item; \n    rand bit  [7:0] a; \n    rand bit  [7:0] b; \n    rand bit  [7:0] c; \n    rand byte kk[];\n    \n    constraint k_cons{ \n        kk.size >= 10; \n        kk.size <= 90;\n    }\n\n    `uvm_object_utils_begin(my_transaction)\n        //'uvm_field_int(a,UVM_ALL_0N)\n        //'uvm_field_int(b,UVM_ALL_0N)\n        `uvm_field_int(c,UVM_ALL_0N)\n        `uvm_field_array_int(kk,UVM_ALL_0N)\n    `uvm_object_utils_end\n    \n    extern function new(string name = \"my_transaction\"); \n\nendclass\n\nfunction my_transaction::new(string name = \"my_transaction\");\n    super.new(name); \nendfunction\n```\n\n之后是sequencer\n\n```verilog\nclass my_sequencer extends uvm_sequencer #(my_transaction);\n\n    `uvm_component_utils(my_sequencer)\n    extern function new(string name, uvm_component parent); \n\nendclass\n\nfunction my_sequencer::new(string name, uvm_component parent);\n    super.new(name,parent); \nendfunction\n```\n\n之后是tx部分\n\n```verilog\nclass tx_driver extends uvm_driver #(my_transaction); \n\n    virtual my_interface vif;\n\n    `uvm_component_utils(tx_driver)\n\n    extern function new(string name, uvm_component parent); \n    extern function void build_phase(uvm_phase phase); \n    extern virtual task reset_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase);\n\nendclass\n\nfunction tx_driver::new(string name, uvm_component parent);\n    super.new(name,parent); \nendfunction\n\nfunction void tx_driver::build_phase(uvm_phase phase); \n    super.build_phase(phase);\n    if (!uvm_config_db#(virtual my_interface)::get(this,\"\",\"vif\",vif))\n        `uvm_fatal(\"tx_driver\",\"virtual interface get fail !\"); \nendfunction\n\ntask tx_driver::reset_phase(uvm_phase phase);\n\n    vif.a <= $urandom_range(8'hff,8'h0); \n    vif.b <= $urandom_range(8'hff,8'h0);\n\nendtask\n\ntask tx_driver::main_phase(uvm_phase phase); \n\n    my_transaction tx_tr; \n\n    super.main_phase(phase); \n\n    while(l)begin\n        seq_item_port.get_next_item(req);\n        tx_tr = req;\n        vif.a <= tx_tr.a;\n        vif.b <= tx_tr.b;\n        seq_item_port.item_done();\n    end\n\nendtask\n```\n\n```verilog\nclass tx_monitor extends uvm_monitor;\n\n    virtual my_interface vif;\n    uvm_analysis_port #(my_transaction) tx_mon_ap;\n    `uvm_component_utils(tx_monitor)\n\n    extern function new(string name, uvm_component parent);\n    extern function void build_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase);\n\nendclass\n\nfunction tx_monitor::new(string name, uvm_component parent);\n    super.new(name,parent); \nendfunction\n\nfunction void tx_monitor::build_phase(uvm_phase phase); \n\n    super.build_phase(phase); \n    tx_mon_ap = new(\"tx_mon_ap\", this);\n    if (!uvm_config_db#(virtual my_interface)::get(this,\"\",\"vif\",vif)) \n        `uvm_fatal(\"tx_monitor\",\"virtual interface get fail !\"); \n\nendfunction\n\ntask tx_monitor::main_phase(uvm_phase phase); \n\n    my_transaction tx_tr; \n    super.main_phase(phase);\n\n    while(l)begin\n        tx_tr = new(); \n        tx_tr.a = vif.a; \n        tx_tr.b = vif.b; \n        tx_mon_ap.write(tx_tr);\n        @(posedge vif.clk);\n    end\n\nendtask\n```\n\n```verilog\nclass tx_agent extends uvm_agent;\n\n    tx_monitor mon;\n    tx_driver  drv;\n    my_sequencer sqr;\n    uvm_analysis_port #(my_transaction) ap;\n    `uvm_component_utils(tx_agent)\n\n    extern function new(string name, uvm_component parent); \n    extern function void build_phase(uvm_phase phase); \n    extern function void connect_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase);\n    \nendclass\n\nfunction tx_agent::new(string name, uvm_component parent);\nsuper.new(name,parent); \nendfunction\n\nfunction void tx_agent::build_phase(uvm_phase phase); \n    super.build_phase(phase);\n    mon = tx_monitor   ::type_id:: create (\"mon\", this); \n    drv = tx_driver    ::type_id:: create (\"drv\", this);\n    sqr = my_sequencer ::type_id:: create (\"sqr\", this);\nendfunction\n\nfunction void tx_agent::connect_phase(uvm_phase phase); \n    super.connect_phase(phase); \n    ap = mon.tx_mon_ap;\n    drv.seq_item_port.connect(sqr.seq_item_export); \nendfunction\n\ntask tx_agent::main_phase(uvm_phase phase);\nsuper.main_phase(phase); \nendtask\n```\n\n之后是rx部分\n\n```verilog\nclass rx_monitor extends uvm_monitor; \n\n    virtual my_interface vif;\n    uvm_analysis_port #(my_transaction) rx_mon_ap;\n    `uvm_component_utils(rx_monitor)\n\n    extern function new(string name, uvm_component parent); \n    extern function void build_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase);\n\nendclass\n\nfunction rx_monitor::new(string new(string name, uvm_component parent);\n    super.new(name,parent); \nendfunction\n\nfunction void rx_monitor::build_phase(uvm_phase phase); \n    super.build_phase(phase); \n    rx_mon_ap = new(\"rx_mon_ap\", this);\n    if (!uvm_config_db#(virtual my_interface)::get(this,\"\",\"vif\",vif)) \n        'uvm_fatal(\"rx_monitor\",\"virtual interface get fail !\"); \nendfunction\n\ntask rx_monitor::main_phase(uvm_phase phase); \n    my_transaction rx_tr; \n    super.main_phase(phase);\n    while(l)begin\n        rx_tr=new();\n        @(posedge vif.clk); \n        rx_tr.c = vif.c; \n        rx_mon_ap.write (rx_tr);\n    end\nendtask\n```\n\n```verilog\nclass rx_agent extends uvm_agent; \n\n    rx_monitor mon;\n    uvm_analysis_port #(my_transaction) ap;\n    `uvm_component_utils(rx_agent)\n\n    extern function new(string name, uvm_component parent); \n    extern function void build_phase(uvm_phase phase); \n    extern function void connect_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase);\n\nendclass\n\nfunction rx_agent::new(string name, uvm_component parent);\n    super.new(name,parent); \nendfunction\n\nfunction void rx_agent::build_phase(uvm_phase phase); \n    super.build_phase(phase);\n    mon = rx_monitor::type_id::create(\"mon\",this); \nendfunction\n\nfunction void rx_agent::connect_phase(uvm_phase phase); \n    super.connect_phase(phase); \n    ap = mon.rx_mon_ap; \nendfunction\n\ntask rx_agent::main_phase(uvm_phase phase);\n    super.main_phase(phase); \nendtask\n```\n\n之后是env\n\n```verilog\nclass env extends uvm_env;\n\n    rx_agent   rx_agt; \n    tx_agent   tx_agt; \n    rm         rm_;\n    scoreboard sc;\n    `uvm_component_utils(env)\n\n    uvm_tlm_analysis_fifo #(my_transaction) mon_rm_fifo; \n    uvm_tlm_analysis_fifo #(my_transaction) rm_sc_fifo; \n    uvm_tlm_analysis_fifo #(my_transaction) sc_mon_fifo;\n\n    extern function new(string name, uvm_component parent); \n    extern function void build_phase(uvm_phase phase); \n    extern function void connect_phase(uvm_phase phase); \n    extern virtual task configure_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase);\n\nendclass\n\nfunction env::new(string name, uvm_component parent);\n    super.new(name,parent);\nendfunction\n\nfunction void env::build_phase(uvm_phase phase); \n\n    super.build_phase(phase);\n\n    rx_agt = rx_agent   ::type_id:: create (\"rx_agt\", this);\n    tx_agt = tx_agent   ::type_id:: create (\"tx_agt\", this);\n    rm_    = rm         ::type_id:: create (\"rm_ \"  , this);\n    sc     = scoreboard ::type_id:: create (\"sc \"   , this);\n    mon_rm_fifo = new(\"mon_rm_fifo\", this); \n    rm_sc_fifo  = new(\"rm_sc_fifo\",  this); \n    sc_mon_fifo = new(\"sc_mon_fifo\", this);\n\nendfunction\n\nfunction void env::connect_phase(uvm_phase phase); \n\n    super.connect_phase(phase);\n\n    tx_agt.ap.  connect(mon_rm_fifo.analysis_export); \n    rm_.port.   connect(mon_rm_fifo.blocking_get_export);\n    rm_.rm_ap.  connect (rm_sc_fifo.analysis_export); \n    sc.rm_port. connect (rm_sc_fifo.blocking_get_export);\n    rx_agt.ap.  connect(sc_mon_fifo.analysis_export);\n    sc.dut_port.connect(sc_mon_fifo.blocking_get_export);\n\nendfunction\n\ntask env::configure_phase(uvm_phase phase);\n    super.configure_phase(phase); \nendtask\n\ntask env::main_phase(uvm_phase phase);\n    super,main_phase(phase); \nendtask\n```\n\n之后是rm\n\n```verilog\nclass rm extends uvm_component;\n\n    uvm_blocking_get_port #(my_transaction) port; \n    uvm_analysis_port #(my_transaction) rm_ap;\n\n    extern function new(string name, uvm_component parent); \n    extern function void build_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase);\n\n    `uvm_component_utils(rm)\n\nendclass\n\nfunction rm::new(string name, uvm_component parent);\n    super.new(name,parent); \nendfunction\n\nfunction void rm::build_phase(uvm_phase phase); \nsuper.build_phase(phase); \nport  = new(\"port\", this); \nrm_ap = new(\"rm_ap\",this); \nendfunction\n\ntask rm::main_phase(uvm_phase phase); \n\n    my_transaction tr; \n    my_transaction send_tr;\n\n    super.main_phase(phase);\n\n    while(l)begin\n        port.get(tr);\n        send_tr = new(\"send_tr\");\n        send_tr = tr;\n        send_tr.c = send_tr.a + send_tr.b; \n        rm_ap.write(send_tr);\n    end\n\nendtask\n```\n\n```verilog\nclass scoreboard extends extends uvm_scoreboard; \n\n    my_transaction rm_queue[$];\n    uvm_blocking_get_port #(my_transaction) rm_port; \n    uvm_blocking_get_port #(my_transaction) dut_port;\n    `uvm_component_utils(scoreboard)\n\n    extern function new(string name, uvm_component parent); \n    extern function void build_phase(uvm_phase phase); \n    extern function void connect_phase(uvm_phase phase); \n    extern virtual task main_phase(uvm_phase phase); \n\nendclass\n\nfunction scoreboard::new(string name, uvm_component parent);\n    super.new(name,parent); \nendfunction\n\nfunction void scoreboard::build_phase(uvm_phase phase); \n    super.build_phase(phase); \n    rm_port  = new(\"rm_port \",this);\n    dut_port = new(\"dut_port\", this); \nendfunction\n\nfunction void scoreboard::connect_phase(uvm_phase phase);\n    super.connect_phase(phase); \nendfunction\n\ntask scoreboard::main_phase(uvm_phase phase); \n\n    my_transaction rm_tr, dut_tr, chk_tr; \n\n    super.main_phase(phase); \n\n    fork\n\n    while(l)begin\n        rm_port.get(rm_tr); \n        rm_queue.push_back(rm_tr);\n    end\n\n    while(l)begin\n        dut_port.get(dut_tr);\n        if (rm_queue.size() > 0)begin\n            chk_tr = rm_queue.pop_front(); \n        if(dut_tr.compare(chk_tr)) begin\n            `uvm_info(\"scoreboard\", \"ok\", UVM_L0W); \n            dut_tr.print (); \n            chk_tr.print (); \n        end else begin\n            `uvm_error(\"scoreboard\", \"fail\");\n        end\n    end\n\n    join\n\nendtask\n```\n"}, {"title": "一个简单的sv验证框架", "url": "sv-test.html", "date": "2020-10-21 21:49:22", "tags": ["sv", "验证"], "content": "\n\n最近一直在做一些小模块的验证，之前都是在用现成的环境修修改改。\n写一个纯sv的环境；\n\n首先是harness；\n\n<!-- more -->\n\n```verilog\n\nmodule harness\n\nbit clk;\nbit rst_n;\n\nw_inf inf(bit clk,bit rst_n);\n\ntc test();\n\ndut dut(\n    clk  (inf.clk),\n    rst_n(inf.rst_n),\n    a    (inf.a),\n    b    (inf.b)\n);\n\ninitial begin\n    clk = 0;\n    forever #0.5ns clk = ~clk;\nend\n\nendmodule\n\n```\n\n之后是interface；\n\n```verilog\ninterface w_inf(bit clk,bit rst_n);\n\n    logic a;\n    logic b;\n    clocking drv_cb @(posedge clk);\n        inout a;\n        inout b;\n    endclocking\n\nendinterface\n```\n\n之后定义一个transaction；\n\n```verilog\nclass transaction\n\n    bit a;\n    bit b;\n\nendclass\n```\n\n之后是定义一个sequence；\n\n```verilog\n\nclass w_sequence\n    \n    bit a[$];\n\n    virtual w_inf bus;\n\n    extern virtual new(w_inf inf);\n\n    extern virtual task tx_process();\n\n    extern virtual task rx_process();\n\n    extern virtual function chk_ans(); \n\nendclass\n\ntask w_sequence::txprocess();\nendtask\n\ntask w_sequence::rxprocess();\nendtask\n\nfunction w_sequence::new(w_inf inf);\n    bus = inf;\nendtask\n\n```\n\n最后定义一下tc;\n\n```verilog\nprogram tc;\n\nsequence seq;\n\nw_inf inf;\n\ninf = harness.inf;\n\ninitial begin\n\n    seq = new(inf);\n\n    fork\n\n    begin\n        seq.tx_process();\n    end\n\n    begin\n        seq.rx_process();\n    end\n\n    begin\n        harness.rst_n = 0; \n        repeat(4)@(posedge vif.clk);\n        harness.rst_n = 1;\n\n        repeat(100)@(posedge vif.clk);\n\n        $finish;\n\n    end\n\n    join\nend\n\nendprogram\n\n```\n"}, {"title": "基于php7的简单web端MySQL后台", "url": "jdsjkht.html", "date": "2019-05-16 15:51:03", "tags": ["x", "php", "MySQL", "web"], "content": "\n\n在web端处理数据库信息要的快捷性更好一些，所有本文针对php7对之前php5的代码做了相关改进，以实现对数据库的增加，删除及更改等功能，在后面的版本中还会增加其适应能力，以及数据库自行识别能力。\n<!-- more -->\n\n以下时相关代码，原php5代码可以参考前辈大佬的[点击进入](https://www.cnblogs.com/cckui/p/8283648.html)\n\n1.0版代码如下：\n\n主界面：\n\n```php+HTML\n<?php\ninclude_once(\"model.php\");//引用处理类文件\n$f=new ht();\n$f -> h_head();\n$f -> h_table();\n$f -> h_footer();\n\n?>\n```\n\n主界面模板文件：\n\n```php+HTML\n<?php\n// model.php(程序处理类)\n Class ht{\n   function h_head(){\n    echo <<< html\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <meta charset=\"UTF-8\">\n    <title>西电导航后台管理系统</title>\n    </head>\n    <style type=\"text/css\">\n    .wrapper {width: 1000px;margin: 20px auto;}\n    h2 {text-align: center;}\n    .add {margin-bottom: 20px;}\n    .add a {text-decoration: none;color: #fff;background-color: green;padding: 6px;border-radius: 5px;}\n    td {text-align: center;}\n    table {\n        table-layout: fixed;\n        word-wrap:break-word;\n        }\n    </style>\n    <body>\n    <div class=\"wrapper\">\n        <h2>西电导航数据库后台管理系统</h2>\n        <div class=\"add\">\n            <a href=\"addnews.html\">增加条目</a>\n        </div>\n        <table width=\"960\" border=\"1\" >\n            <tr>\n                <th>标题</th>\n                <th>url</th>\n                <th>发布时间</th>\n                <th>内容</th>\n                <th>操作</th>\n            </tr>\nhtml;\n   }\n\n\n   function h_footer(){\n       echo <<< html\n        </table>\n        </div>\n        </div>\n        <script type=\"text/javascript\">\n        function del (id) {\n            if (confirm(\"确定删除这条新闻吗？\")){\n                window.location = \"action-del.php?title=\"+id;\n            }\n        }\n        </script>\n        </body>\n        </html>\nhtml;\n    }\n\n\n    function h_table(){\n        header(\"Content-type: text/html; charset=utf-8\");\n        $servername = \"localhost\";\n        $username = \"root\";\n        $password = \"root\";\n        $conn = new mysqli($servername, $username, $password,\"test\");\n    \n        if ($conn->connect_error) {\n            die(\"连接失败: \" . $conn->connect_error);\n          } \n        mysqli_set_charset($conn,'utf8'); \n        // 3. 从DBNAME中查询到news数据库，返回数据库结果集,并按照addtime降序排列  \n        // 结果集\n        $result = mysqli_query($conn,\"SELECT * FROM bs_3\");\n        // var_dump($result);die;\n    \n        // 解析结果集,$row为新闻所有数据，$newsNum为新闻数目\n        $newsNum=mysqli_num_rows($result);\n\n        for($i=0; $i<$newsNum; $i++){\n            $row = mysqli_fetch_assoc($result);\n            echo \"<tr>\";\n            echo \"<td>{$row['title']}</td>\";\n            echo \"<td>{$row['url']}</td>\";\n            echo \"<td>{$row['t_date']}</td>\";\n            echo \"<td>{$row['page']}</td>\";\n            echo \"<td>\n                    <a href='javascript:del(\\\"{$row['title']}\\\")'>删除</a>\n                    <a href='editnews.php?id={$row['title']}'>修改</a>\n                  </td>\";\n            echo \"</tr>\";\n        }\n        }\n\n }\n\n?>\n```\n\n添加界面：\n\n```HTML\n<!DOCTYPE html>  \n<html>  \n<head lang=\"en\">  \n    <meta charset=\"UTF-8\">  \n    <title>添加内容</title>  \n</head>\n<style type=\"text/css\">\n    form{\n        margin: 20px;\n    }\n</style>\n<body>\n<form action=\"action-addnews.php\" method=\"post\">  \n    <label>标题：</label><input type=\"text\" name=\"title\">  \n    <label>url:</label><input type=\"text\" name=\"url\">   \n    <label>发布时间：</label><input type=\"date\" name=\"t_date\">  \n    <label>内容：</label><input type=\"text\" name=\"page\">  \n    <input type=\"submit\" value=\"提交\">  \n</form>  \n</body>  \n</html>\n```\n\n添加操作执行代码：\n\n```php\n<?php\n// 处理增加操作的页面 \nrequire \"dbconfig.php\";\n// 连接mysql\n$link = @mysqli_connect(HOST,USER,PASS) or die(\"提示：数据库连接失败！\");\n// 选择数据库\nmysqli_select_db($link,DBNAME);\n// 编码设置\nmysqli_set_charset($link,'utf8');\n\n// 获取增加的新闻\n$title = $_POST['title'];\n$url = $_POST['url'];\n$t_date = $_POST['t_date'];\n$page = $_POST['page'];\n// 插入数据\nmysqli_query($link,\"INSERT INTO bs_3(title,url,t_date,page) VALUES ('$title','$url','$t_date','$page')\") or die('添加数据出错!'); \nheader(\"Location:index.php\");  \n```\n\n删除操作：\n\n```php\n<?php\n// 处理删除操作的页面 \nrequire \"dbconfig.php\";\n// 连接mysql\n$link = @mysqli_connect(HOST,USER,PASS) or die(\"提示：数据库连接失败！\");\n// 选择数据库\nmysqli_select_db($link,DBNAME);\n// 编码设置\nmysqli_set_charset($link,'utf8');\n\n$title = $_GET['title'];\necho $title;\n$title=str_replace('\"','',$title);\n//删除指定数据  \nmysqli_query($link,\"DELETE FROM bs_3 WHERE title='$title'\")or die(\"提示：删除失败\");\n// 删除完跳转到新闻页\n\necho $title;\nheader(\"Location:index.php\");  \n?>\n```\n\n修改操作：\n\n界面：\n\n```php+HTML\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>修改数据库内容</title>\n</head>\n<body>\n<?php\n    require \"dbconfig.php\";\n\n    $link = @mysqli_connect(HOST,USER,PASS) or die(\"提示：数据库连接失败！\");\n    mysqli_select_db($link,DBNAME);\n    mysqli_set_charset($link,'utf8');\n    \n    $id = $_GET['id'];\n    $sql = mysqli_query($link,\"SELECT * FROM bs_3 WHERE title='$id'\");\n    echo \"请谨慎修改\";\n    $sql_arr =  mysqli_fetch_assoc($sql); \n\n?>\n\n<form action=\"action-editnews.php\" method=\"post\">\n    <label>标题：</label><input type=\"text\" name=\"title\" value=\"<?php echo $sql_arr['title']?>\">\n    <label>url：</label><input type=\"text\" name=\"url\" value=\"<?php echo $sql_arr['url']?>\">\n    <label>发布时间：</label><input type=\"date\" name=\"t_date\" value=\"<?php echo $sql_arr['t_date']?>\">\n    <label>内容：</label><input type=\"text\" name=\"page\" value=\"<?php echo $sql_arr['page']?>\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n\n</body>\n</html>\n```\n\n执行：\n\n```php\n<?php\n// 处理编辑操作的页面 \nrequire \"dbconfig.php\";\n// 连接mysql\n$link = @mysqli_connect(HOST,USER,PASS) or die(\"提示：数据库连接失败！\");\n// 选择数据库\nmysqli_select_db($link,DBNAME);\n// 编码设置\nmysqli_set_charset($link,'utf8');\n\n// 获取修改的新闻\n$title = $_POST['title'];\n$url = $_POST['url'];\n$t_date = $_POST['t_date'];\n$page = $_POST['page'];\n// 更新数据\nmysqli_query($link,\"UPDATE bs_3 SET title='$title',url='$url',t_date='$t_date',page='$page' WHERE title='$title'\") or die('修改数据出错：'); \nheader(\"Location:index.php\");  \n```\n\n数据库关键信息写入页：\n\n```php\n<?php  \ndefine(\"HOST\",\"localhost\");  \ndefine(\"USER\",\"root\");  \ndefine(\"PASS\",\"root\");\ndefine(\"DBNAME\",\"test\");\n```\n\n"}]